<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>1.1 QHTML Introduction</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="index.html">- Up -</A></TD><TD><A href="node2.html#chapter.prototyper">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.introduction"><H2><A name="chapter.introduction">1.1 QHTML Introduction</A></H2><P></P><H3><A name="label1">1.1.1 Introduction</A></H3><P></P><P>The QHTML module implements a description based abstraction to help programmers efficiently build graphical user interfaces. Windows are built in a declarative way, expressing the widgets that compose the window along with their geometry. Widgets can be dynamically controled using handlers. The user interface itself appear in an Internet browser. For now only Internet Explorer 5.5 and above are supported. Using QHTML it is very easy to create client-server like application where the clients provide the user interface while the server provides the functionalities of the application. As the user interface appears in an Internet browser, the application is available anywhere in the world where an Internet connection exist.</P><P></P><P></P><H3><A name="label2">1.1.2 Description-based User Interface Specification</A></H3><P></P><P>With the QHTML module the user interfaces are defined by descriptions. A description is a record value that defines the initial state of the user interface and several hooks to interact dynamically with it afterwards.</P><P></P><P>In general, there are three main ways of defining user interfaces: </P><P></P><UL><LI><P>By means of explicit calls to a user interface toolbox.</P><P></P></LI><LI><P>By means of an Interface Builder, a graphical tool that allows to create the interface interactively.</P><P></P></LI><LI><P>By means of descriptions. A description is a data structure that defines the user interface.</P><P></P></LI></UL><P>QHTML uses the description approach, where the descriptions are record values. (The QHTML Prototyper provides an interactive interface; this regains part of the advantage of using an Interface Builder.) (The Macintosh has popularized the notion of ``resources'', which are graphical descriptions of user interfaces that correspond to records. However, they are intended to be used graphically, through an Interface Builder. They are much more cumbersome to use than records, for example, they cannot be easily calculated in programs.)</P><P></P><P>The description approach is particularly useful in a symbolic language such as Oz that allows easy and concise creation of data structures. QHTML uses record values, which are well-supported by Oz. For example, the following code defines a record and references it in D: </P><P></P><BLOCKQUOTE class="code"><CODE>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">declare</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;D=td(button(value:<SPAN class="string">&quot;Show&quot;</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action:<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>}&nbsp;{Show&nbsp;<SPAN class="string">'Hello&nbsp;World'</SPAN>}&nbsp;<SPAN class="keyword">end</SPAN>)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button(value:<SPAN class="string">&quot;Close&quot;</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action:toplevel<SPAN class="keyword">#</SPAN>close))</CODE></BLOCKQUOTE><P></P><P>The record with label <CODE>td</CODE> has two fields that define two buttons in two records. It defines a window with two buttons, labeled <CODE>Show</CODE> and <CODE>Close</CODE>, which are linked to the actions of displaying Hello World and closing the window.</P><P></P><P>There are at least five advantages to using descriptions: </P><P></P><UL><LI><P>Descriptions are part of the source language. They allow to describe the user interface without leaving the source language.</P><P></P></LI><LI><P>It is possible to calculate descriptions. For example, if the buttons are arranged in a geometrical pattern (e.g., over a map).</P><P></P></LI><LI><P>Since descriptions are values, they can be saved in files and loaded at will.</P><P></P></LI><LI><P>Saving descriptions in Ascii form allows them to be inspected and edited by humans.</P><P></P></LI><LI><P>Records in Oz are written in a very concise, symbolic way. This means that the description itself is already a kind of visual representation. As a result, the conceptual distance between the description and its user interface meaning is small.</P><P></P></LI></UL><P>By mixing functions and records, descriptions can be made both concise and readable. Here's an example: </P><P></P><BLOCKQUOTE class="code"><CODE>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">declare</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;In&nbsp;Out<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Txt</SPAN>&nbsp;T&nbsp;H&nbsp;S}&nbsp;lr(glue:nswe<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label(value:T)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;textarea(handle:H&nbsp;glue:nswe))&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">But</SPAN>&nbsp;T&nbsp;A}&nbsp;button(glue:we&nbsp;value:T&nbsp;action:A)&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;D=tdframe(tdframe(glue:nswe<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Txt&nbsp;<SPAN class="string">&quot;Expression&quot;</SPAN>&nbsp;In}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Txt&nbsp;<SPAN class="string">&quot;Result&quot;</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Out})<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lr(glue:we<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{But&nbsp;<SPAN class="string">&quot;Eval&quot;</SPAN>&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>}&nbsp;V={E&nbsp;{In&nbsp;get($)}}&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;{Out&nbsp;set(V)}&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{But&nbsp;<SPAN class="string">&quot;Quit&quot;</SPAN>&nbsp;toplevel<SPAN class="keyword">#</SPAN>close}))</CODE></BLOCKQUOTE><P></P><P>The result in <CODE>D</CODE> is still a record value, but the source code is shorter. This defines a window with one rubber frame, two text labels, two text boxes (including one with scrollbar), two buttons (each with an action). One of the actions is a procedure that does a calculation (defined by the function <CODE>E</CODE>), the other simply closes the window. The text boxes have 'handles', which allow to do things with the text--here, one of the boxes is read (through the '<CODE>get</CODE>' method) and the other is written (through the '<CODE>set</CODE>' method). </P><P></P><P> </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="index.html">- Up -</A></TD><TD><A href="node2.html#chapter.prototyper">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS>Donatien Grolaux<BR><SPAN class="version">Version 1.3.0 (20010902)</SPAN></ADDRESS></BODY></HTML>
