<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>5 Advanced topics</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node4.html#chapter.basics">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node6.html#chapter.stddialog">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.advanced"><H1><A name="chapter.advanced">5 Advanced topics</A></H1><DIV id="misc.look"><H2><A name="misc.look">5.1 Looks</A></H2><P>Default parameters of widgets can be specified and grouped into &quot;looks&quot;. A look is obtained by: </P><BLOCKQUOTE class="code"><CODE>L={QTk<SPAN class="keyword">.</SPAN>newLook}</CODE></BLOCKQUOTE><P> Default parameters for a specific widget are specified by: </P><BLOCKQUOTE class="code"><CODE>{L<SPAN class="keyword">.</SPAN>set&nbsp;widgetname(param1:value1&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;paramX:valueX)}</CODE></BLOCKQUOTE><P> Example: </P><BLOCKQUOTE class="code"><CODE>{L<SPAN class="keyword">.</SPAN>set&nbsp;entry(background:white)}</CODE></BLOCKQUOTE><P> specifies that the entries will have a white background by default for the look L.</P><P>All widgets support a <CODE>look</CODE> parameter that specifies the look to use. Except when explicitly stated, widgets that serve as container for other widgets propagate their look parameter to their contained widgets automatically. If a contained widget defines a look itself, it overrides the inherited look from its parent container. </P><BLOCKQUOTE class="code"><CODE>L1={QTk<SPAN class="keyword">.</SPAN>newLook}<BR>{L1<SPAN class="keyword">.</SPAN>set&nbsp;entry(background:white)}<BR>{L1<SPAN class="keyword">.</SPAN>set&nbsp;label(background:red)}<BR>L2={QTk<SPAN class="keyword">.</SPAN>newLook}<BR>{L2<SPAN class="keyword">.</SPAN>set&nbsp;label(background:blue)}<BR>{{QTk<SPAN class="keyword">.</SPAN>build&nbsp;td(look:L1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry(text:<SPAN class="string">&quot;Type&nbsp;here&quot;</SPAN>)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label(text:<SPAN class="string">&quot;Inherited&nbsp;red&nbsp;background&quot;</SPAN>)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label(text:<SPAN class="string">&quot;Overrided&nbsp;blue&nbsp;background&quot;</SPAN>&nbsp;look:L2))}&nbsp;show}</CODE></BLOCKQUOTE><P></P></DIV><H2><A name="label8">5.2 Using a toolkit forbidding class specializations.</A></H2><P>At this point of the documentation, the declarative approach of the construction of windows should be clear in the reader's mind. Another important point is once the window is constructed and for all its lifetime, how does QTk compare to other toolkits?</P><P>QTk is rather different in its approach than classical object-oriented user-interface toolkits. Developers using these toolkits are often used to a specialization approach where all the components of the UI of the application are objects that are specializations of the available widget classes. Well, this approach has a major drawback: the functionality of the application is strongly inter-mixed with its user-interface. This makes any major change of the UI very expensive, but also any major change of the functionality of the application <EM>can</EM> suffer from the UI implementation. Applying the separation of concern principle, the UI implementation must be as separated as possible from the functional core of the application. The specialization feature of the object-orientation approach favors the exact opposite.</P><P>The QTk toolkit is <EM>not</EM> used as an object-oriented toolkit, but as an object-<EM>based</EM> one. The specialization process is consequently impossible, <EM>which is a good property</EM> when developing applications. QTk offers a different way to create specialized widgets: QTk aliases (see below).</P><P>When the habit of specializing widgets is strong, it may be difficult to see how to achieve the same level of expressiveness with QTk. There are two keys in achieving this: </P><UL><LI><P>View/controller pattern: whenever the application needs to view or control the state of a widget, use a handle. The functional part of the application is a <EM>user</EM> of these handles.</P></LI><LI><P>Natural Oz capability to wrap entities: first class procedures, records, classes or whatever is fitted for the task.</P></LI></UL><P></P><P><EM>Example: a numberentry widget with save and load functionality</EM></P><P>Using a view/controller pattern so that the functionality of this customized widget uses the handle of the <CODE>numberentry</CODE> widget: </P><BLOCKQUOTE class="code"><CODE>Desc=lr(numberentry(handle:Handle)&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tbbutton(text:<SPAN class="string">&quot;Save&quot;</SPAN>&nbsp;action:Save)&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tbbutton(text:<SPAN class="string">&quot;Load&quot;</SPAN>&nbsp;action:Load))<BR>&nbsp;<BR><SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">Save</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;{Pickle<SPAN class="keyword">.</SPAN>save&nbsp;Filename&nbsp;{Handle&nbsp;get($)}}<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;<BR><SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">Load</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;{Handle&nbsp;set({Pickle<SPAN class="keyword">.</SPAN>load&nbsp;Filename})}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> Using an Oz wrapper: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">fun</SPAN>{<SPAN class="functionname">MyNumberEntry</SPAN>&nbsp;Filename&nbsp;Handle}<BR>&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="comment">%&nbsp;code&nbsp;above<BR></SPAN><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;Desc<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> Using the customized widget inside a QTk window: </P><BLOCKQUOTE class="code"><CODE>{{QTk<SPAN class="keyword">.</SPAN>build&nbsp;lr(label(text:<SPAN class="string">&quot;Customized&nbsp;numberentry&nbsp;widget:&quot;</SPAN>)&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{MyNumberEntry&nbsp;<SPAN class="string">&quot;value&quot;</SPAN>&nbsp;_})}&nbsp;show}</CODE></BLOCKQUOTE><P> It is strongly advised to use such technique only when relevant, that is when there is a strong reason to couple the user interface and the functionality of the application that uses it. </P><H2><A name="label9">5.3 QTk aliases</A></H2><P>The creation of brand new widgets is a particular case where it is strongly advised to couple the user interface and its functionality. Note that if some part of the UI of an application has little to no meaning outside the context of this application, then that part of the UI is a very poor widget candidate. On the opposite, all parts of the UI that still have a meaning on their own outside the context of the application are very good widget candidates.</P><P>QTk offers a specific support to let users expand the widget database: aliases. To avoid name clash problems, aliases cannot be defined with the default QTk builder, the application has to ask a new one: </P><BLOCKQUOTE class="code"><CODE>MyBuilder={QTk<SPAN class="keyword">.</SPAN>newBuilder}</CODE></BLOCKQUOTE><P> Aliases can be defined in 3 different ways: </P><UL><LI><P>Aliases as records that define shortcuts to default values: </P><BLOCKQUOTE class="code"><CODE>{MyBuilder<SPAN class="keyword">.</SPAN>setAlias&nbsp;ilabel&nbsp;label(bg:black&nbsp;fg:white)}<BR>{{MyBuilder<SPAN class="keyword">.</SPAN>build&nbsp;td(ilabel(text:<SPAN class="string">&quot;Inverted&nbsp;label&quot;</SPAN>)&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ilabel(text:<SPAN class="string">&quot;Inverted&nbsp;label&nbsp;with&nbsp;overriden&nbsp;foreground&nbsp;color&quot;</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fg:red))}&nbsp;show}</CODE></BLOCKQUOTE><P> Note how QTk looks define a single default set of parameters for each different type of widgets in a local area of the window, while aliases define several sets of parameters for possibly the same type of widget and for the entirety of the window. </P></LI><LI><P>Aliases as functions that are applied at the widget construction time: </P><BLOCKQUOTE class="code"><CODE>{MyBuilder<SPAN class="keyword">.</SPAN>setAlias&nbsp;tdl<BR>&nbsp;<SPAN class="keyword">fun</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;M}<BR>&nbsp;&nbsp;&nbsp;&nbsp;Num&nbsp;Other<BR>&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;{Record<SPAN class="keyword">.</SPAN>partitionInd&nbsp;M&nbsp;<SPAN class="keyword">fun</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;I&nbsp;_}&nbsp;{Int<SPAN class="keyword">.</SPAN>is&nbsp;I}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;Num&nbsp;Other}<BR>&nbsp;&nbsp;&nbsp;&nbsp;{Record<SPAN class="keyword">.</SPAN>adjoin<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Other<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{List<SPAN class="keyword">.</SPAN>toTuple&nbsp;td<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{List<SPAN class="keyword">.</SPAN>flatten&nbsp;{Record<SPAN class="keyword">.</SPAN>toList&nbsp;Num}}}}<BR>&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;<BR>{{MyBuilder<SPAN class="keyword">.</SPAN>build&nbsp;td(tdl([label(text:<SPAN class="string">&quot;A&quot;</SPAN>)]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[label(text:<SPAN class="string">&quot;B&quot;</SPAN>)&nbsp;label(text:<SPAN class="string">&quot;C&quot;</SPAN>)]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label(text:<SPAN class="string">&quot;D&quot;</SPAN>)))}&nbsp;show}</CODE></BLOCKQUOTE><P> When the <CODE>tdl</CODE> widget is found during the window construction process, the function defined by the alias is called with the record describing the widget as parameter. The window construction process resumes by substituting the alias by the result of the function call. Note that the actual parameter given to the alias function may be different from the record in the window declaration as QTk automatically appends <CODE>look</CODE> information.</P></LI><LI><P>Aliases as classes: </P><BLOCKQUOTE class="code"><CODE>{MyBuilder<SPAN class="keyword">.</SPAN>setAlias&nbsp;labelddlb<BR>&nbsp;<SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">$</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">feat</SPAN>&nbsp;label&nbsp;ddlb<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">labelddlb</SPAN>(<SPAN class="keyword">...</SPAN>)=M<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M<SPAN class="keyword">.</SPAN>(QTk<SPAN class="keyword">.</SPAN>qTkDesc)=lr(glue:we<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label(handle:<SPAN class="keyword">self.</SPAN>label&nbsp;glue:we)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dropdownlistbox(handle:<SPAN class="keyword">self.</SPAN>ddlb<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action:<SPAN class="keyword">self#</SPAN>select<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init:M<SPAN class="keyword">.</SPAN>init))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="comment">%&nbsp;waits&nbsp;for&nbsp;the&nbsp;widget&nbsp;to&nbsp;be&nbsp;built<BR></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Wait&nbsp;<SPAN class="keyword">self.</SPAN>ddlb}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="comment">%&nbsp;actions&nbsp;to&nbsp;do&nbsp;when&nbsp;the&nbsp;widget&nbsp;is&nbsp;first&nbsp;built<BR></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;M<SPAN class="keyword">.</SPAN>init<SPAN class="keyword">\=</SPAN>nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">self.</SPAN>label&nbsp;set(M<SPAN class="keyword">.</SPAN>init<SPAN class="keyword">.</SPAN>1)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">set</SPAN>(<SPAN class="keyword">...</SPAN>)=M<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">self.</SPAN>ddlb<SPAN class="keyword">,</SPAN>M<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;select}<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">get</SPAN>(<SPAN class="keyword">...</SPAN>)=M<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">self.</SPAN>ddlb<SPAN class="keyword">,</SPAN>M<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">select</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">self.</SPAN>label&nbsp;set({<SPAN class="keyword">self.</SPAN>ddlb&nbsp;get(firstselection:$)})}<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;<SPAN class="keyword">end</SPAN>}<BR>{{MyBuilder<SPAN class="keyword">.</SPAN>build&nbsp;lr(labelddlb(init:[1&nbsp;2&nbsp;3&nbsp;4]))}&nbsp;show}</CODE></BLOCKQUOTE><P> This method is an enhanced version of the previous one. The constructor method of the class must have the name of the alias, and it is called with the actual record used in the window declaration with an added parameter: <CODE>QTk<SPAN class="keyword">.</SPAN>qTkDesc</CODE>. This parameter defines the substitution record to use instead of the alias. Note that using classes, the following parameters are automatically managed and must not be taken into account: <CODE>handle</CODE>, <CODE>feature</CODE>, <CODE>glue</CODE>. <CODE>handle</CODE> parameters are bound to the instance of the alias class created as if this class was a regular QTk widget class.</P></LI></UL><P> <EM>More examples: adding list support for container widgets</EM></P><P class="margin"><A href="listcont.oz">Source File</A></P><P> </P><BLOCKQUOTE><PRE><SPAN class="keyword">declare</SPAN>
<BR>
<BR>[QTk]={Module<SPAN class="keyword">.</SPAN>link&nbsp;[<SPAN class="string">&quot;x-oz://system/wp/QTk.ozf&quot;</SPAN>]}
<BR>
<BR>Builder={QTk<SPAN class="keyword">.</SPAN>newBuilder}
<BR>
<BR>{ForAll&nbsp;[td&nbsp;lr&nbsp;grid]
<BR>&nbsp;<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;V}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;{Builder<SPAN class="keyword">.</SPAN>setAlias&nbsp;{VirtualString<SPAN class="keyword">.</SPAN>toAtom&nbsp;V<SPAN class="keyword">#</SPAN>l}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">fun</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;M}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Num&nbsp;Other
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">in</SPAN>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Record<SPAN class="keyword">.</SPAN>partitionInd&nbsp;M&nbsp;<SPAN class="keyword">fun</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;I&nbsp;_}&nbsp;{Int<SPAN class="keyword">.</SPAN>is&nbsp;I}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;Num&nbsp;Other}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Record<SPAN class="keyword">.</SPAN>adjoin
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Other
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{List<SPAN class="keyword">.</SPAN>toTuple&nbsp;V
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{List<SPAN class="keyword">.</SPAN>flatten&nbsp;{Record<SPAN class="keyword">.</SPAN>toList&nbsp;Num}}}}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>}
<BR>&nbsp;<SPAN class="keyword">end</SPAN>}
<BR>
<BR><SPAN class="comment">%{{Builder.build&nbsp;td(tdl([label(text:&quot;A&quot;)]&nbsp;[label(text:&quot;B&quot;)&nbsp;label(text:&quot;C&quot;)]&nbsp;label(text:&quot;D&quot;)))}&nbsp;show}
<BR></SPAN></PRE></BLOCKQUOTE><P></P><P></P><H2><A name="label10">5.4 QTk builders</A></H2><P>The previous chapter already showed an example of a QTk builder. A QTk builder groups together: </P><UL><LI><P>A list of widgets</P></LI><LI><P>A list of aliases</P></LI><LI><P>A default look for widgets</P></LI></UL><P> By default, all QTk builders include the following widgets and aliases: <CODE>button</CODE>, <CODE>canvas</CODE>, <CODE>checkbutton</CODE>, <CODE>dropdownlistbox</CODE>, <CODE>entry</CODE>, <CODE>grid</CODE>, <CODE>label</CODE>, <CODE>listbox</CODE>, <CODE>lr</CODE>, <CODE>lrline</CODE>, <CODE>lrrubberframe</CODE>, <CODE>lrscale</CODE>, <CODE>lrscrollbar</CODE>, <CODE>lrspace</CODE>, <CODE>menubutton</CODE>, <CODE>message</CODE>, <CODE>numberentry</CODE>, <CODE>panel</CODE>, <CODE>placeholder</CODE>, <CODE>radiobutton</CODE>, <CODE>scrollframe</CODE>, <CODE>tbbutton</CODE>, <CODE>tbcheckbutton</CODE>, <CODE>tbradiobutton</CODE>, <CODE>td</CODE>, <CODE>tdline</CODE>, <CODE>tdrubberframe</CODE>, <CODE>tdscale</CODE>, <CODE>tdscrollbar</CODE>, <CODE>tdspace</CODE> and <CODE>text</CODE>.</P><P>A QTk builder is obtained by: </P><BLOCKQUOTE class="code"><CODE>MyBuilder={QTk<SPAN class="keyword">.</SPAN>newBuilder}</CODE></BLOCKQUOTE><P> And supports the following functions and procedures: </P><UL><LI><P><CODE>{MyBuilder<SPAN class="keyword">.</SPAN>build&nbsp;Desc}</CODE>: builds the window corresponding to <CODE>Desc</CODE> where <CODE>Desc</CODE> is a description record, according to the widget and alias database, and to the default look defined in <CODE>MyBuilder</CODE>.</P></LI><LI><P><CODE>{MyBuilder<SPAN class="keyword">.</SPAN>register&nbsp;Widget}</CODE>: register a regular QTk widget. This should not be used outside QTk itself, use aliases instead.</P></LI><LI><P><CODE>MyBuilder<SPAN class="keyword">.</SPAN>defaultLook</CODE>: defines the default <CODE>look</CODE> (<A href="node5.html#misc.look">Section&nbsp;5.1</A>) for widgets.</P></LI><LI><P><CODE>{MyBuilder<SPAN class="keyword">.</SPAN>setAlias&nbsp;AliasName&nbsp;Alias}</CODE>: defines an alias (see above).</P></LI><LI><P><CODE>{MyBuilder<SPAN class="keyword">.</SPAN>unSetAlias&nbsp;AliasName}</CODE>: removes an alias from the alias database of <CODE>MyBuilder</CODE>.</P></LI><LI><P><CODE>{MyBuilder<SPAN class="keyword">.</SPAN>getAlias&nbsp;AliasName}</CODE>: returns the function applied to transform the <CODE>AliasName</CODE> alias description in the window description record. Altough an alias can be specified in three different forms (record, function or class), <CODE>getAlias</CODE> returns only a one parameter function that is semantically equivalent to the initial alias specification.</P></LI><LI><P><CODE>{MyBuilder<SPAN class="keyword">.</SPAN>getWidgetList}</CODE>: returns the list of all widgets defined in <CODE>MyBuilder</CODE>.</P></LI><LI><P><CODE>{MyBuilder<SPAN class="keyword">.</SPAN>getAliasList}</CODE>: returns the list of all aliases defined in <CODE>MyBuilder</CODE>.</P></LI></UL><P> There exists a default builder inside QTk. <CODE>QTk<SPAN class="keyword">.</SPAN>build</CODE> uses the <CODE>build</CODE> function of this default builder. However users are not allowed to modify the widget or alias database, nor the default look of this default builder. Therefore <CODE>QTk<SPAN class="keyword">.</SPAN>build</CODE> creates always the same windows depending only on the description record used.</P><H2><A name="label11">5.5 QTk.flush</A></H2><P>For efficiency reasons, all commands send to the windowing system are batched together. Because of that, a widget might fail to return some information about itself, generally regarding its actual height and width. The command <CODE>{QTk<SPAN class="keyword">.</SPAN>flush}</CODE> blocks until all pending commands of the windowing system have been processed.</P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node4.html#chapter.basics">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node6.html#chapter.stddialog">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS>Donatien Grolaux<BR><SPAN class="version">Version 1.3.0 (20040413)</SPAN></ADDRESS></BODY></HTML>
