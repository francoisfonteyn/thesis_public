<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>1 Introduction</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="index.html">- Up -</A></TD><TD><A href="node2.html#chapter.prototyper">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.introduction"><H1><A name="chapter.introduction">1 Introduction</A></H1><P> The <CODE>QTk</CODE> module implements a description-based abstraction to help programmers efficiently build graphical user interfaces. Windows are built in a declarative way, expressing the widgets that compose the window along with their geometry. Widgets can be dynamically controlled by handles. Miscellaneous facilities are also provided to facilitate the development of an application's GUI. The <CODE>QTk</CODE> module is dedicated to <EM>Oz 3</EM>. It can be loaded by: </P><UL><LI><P>From the OPI: <CODE><SPAN class="keyword">declare</SPAN>&nbsp;[QTk]={Module<SPAN class="keyword">.</SPAN>link&nbsp;[<SPAN class="string">&quot;x-oz://system/wp/QTk.ozf&quot;</SPAN>]}</CODE></P></LI><LI><P>In a functor, in the <CODE><SPAN class="keyword">import</SPAN></CODE> part: <CODE><SPAN class="keyword">import</SPAN>&nbsp;QTk&nbsp;<SPAN class="keyword">at</SPAN>&nbsp;<SPAN class="string">'x-oz://system/wp/QTk.ozf'</SPAN></CODE></P></LI></UL><P> </P><P> The documentation is split in the following chapters: </P><UL><LI><P><A href="node2.html#chapter.prototyper">Chapter&nbsp;2</A> The Prototyper application</P></LI><LI><P><A href="node3.html#chapter.example">Chapter&nbsp;3</A> Tutorial example: a notepad application</P></LI><LI><P><A href="node4.html#chapter.basics">Chapter&nbsp;4</A> Basics</P></LI><LI><P><A href="node5.html#chapter.advanced">Chapter&nbsp;5</A> Advanced topics</P></LI><LI><P><A href="node6.html#chapter.stddialog">Chapter&nbsp;6</A> Standard dialog boxes</P></LI><LI><P><A href="node7.html#chapter.widgets">Chapter&nbsp;7</A> Widget reference</P></LI><LI><P><A href="node34.html#chapter.misc">Chapter&nbsp;8</A> Miscellaneous</P></LI></UL><P> </P><H2><A name="label1">1.1 Description-based User Interface Specification</A></H2><P>The QTk module is based on using <EM>descriptions</EM> to define user interfaces. A description is an Oz record value.</P><P>In general, there are three main ways of defining user interfaces: </P><UL><LI><P>By means of explicit calls to a user interface toolbox (Tcl/Tk, AWT, GTk, ...).</P></LI><LI><P>By means of an Interface Builder, a graphical tool that allows to create the interface interactively (Visual tools, Delphi, ...).</P></LI><LI><P>By means of <EM>descriptions</EM>. A description is a data structure that defines the user interface (HTML, XML, ...).</P></LI></UL><P> QTk uses the description approach, where the descriptions are Oz record values. Note that the QTk Prototyper provides an interactive interface; this regains part of the advantage of using an Interface Builder. The Macintosh has popularized the notion of &quot;resources&quot;, which are graphical descriptions of user interfaces that correspond to records. However, they are intended to be used graphically, through an Interface Builder. Consequently they are limited to parts of the user interface known before the execution of the application. Description records on the other hand can be calculated on the fly as needed at runtime by the application.</P><P>The description approach is particularly useful in a symbolic language such as Oz that allows easy and concise creation of data structures. QTk uses record values, which are well supported by Oz. For example, the following code defines a record and references it in D: </P><BLOCKQUOTE class="code"><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">declare</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;D=td(button(text:<SPAN class="string">&quot;Show&quot;</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action:<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>}&nbsp;{Show&nbsp;<SPAN class="string">'Hello&nbsp;World'</SPAN>}&nbsp;<SPAN class="keyword">end</SPAN>)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Close&quot;</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action:toplevel<SPAN class="keyword">#</SPAN>close))<BR></CODE></BLOCKQUOTE><P> The record with label <CODE>td</CODE> has two fields that themselves contain records defining two buttons that are labelled Show and Close. These buttons are linked to the actions of displaying <CODE>Hello&nbsp;World</CODE> and closing the window.</P><P>There are at least five advantages to using descriptions: </P><UL><LI><P>Descriptions are part of the source language. The user interface are described without leaving the source language.</P></LI><LI><P>It is possible to calculate descriptions at runtime, as dynamically required by the application.</P></LI><LI><P>Since descriptions are values, they can be saved in files and loaded at will.</P></LI><LI><P>Saving descriptions in Ascii form allows them to be inspected and edited by humans.</P></LI><LI><P>Records in Oz are written in a very concise, symbolic way. This means that the description itself is already a kind of visual representation. As a result, the conceptual distance between the description and its user interface meaning is small.</P></LI></UL><P> By mixing functions and records, descriptions can be made both concise and readable. Here's an example: </P><BLOCKQUOTE class="code"><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">declare</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;In&nbsp;Out<BR>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Txt</SPAN>&nbsp;T&nbsp;H&nbsp;S}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lr(glue:nswe<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label(text:T)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text(handle:H&nbsp;glue:nswe&nbsp;tdscrollbar:S))&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">But</SPAN>&nbsp;T&nbsp;A}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button(glue:we&nbsp;text:T&nbsp;action:A)&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;<BR>&nbsp;&nbsp;&nbsp;D=td(tdrubberframe(glue:nswe<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Txt&nbsp;<SPAN class="string">&quot;Expression&quot;</SPAN>&nbsp;In&nbsp;&nbsp;<SPAN class="keyword">false</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Txt&nbsp;<SPAN class="string">&quot;Result&quot;</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Out&nbsp;<SPAN class="keyword">true</SPAN>})<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lr(glue:we<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{But&nbsp;<SPAN class="string">&quot;Eval&quot;</SPAN>&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>}&nbsp;V={E&nbsp;{In&nbsp;get($)}}&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;{Out&nbsp;set(V)}&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{But&nbsp;<SPAN class="string">&quot;Quit&quot;</SPAN>&nbsp;toplevel<SPAN class="keyword">#</SPAN>close}))<BR></CODE></BLOCKQUOTE><P> The functions <CODE>Txt</CODE> and <CODE>But</CODE> shorten the writing of the record <CODE>D</CODE>. This defines a window with one rubber frame, two text labels, two text boxes (including one with scrollbar), two buttons (each with an action). One of the actions is a procedure that does a calculation (defined by the function E), the other simply closes the window. The text boxes have <CODE>handle</CODE> parameters that give control over these widgets. Here, one of the boxes is read (through the <CODE>get</CODE> method) and the other is written (through the <CODE>set</CODE> method). </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="index.html">- Up -</A></TD><TD><A href="node2.html#chapter.prototyper">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS>Donatien Grolaux<BR><SPAN class="version">Version 1.3.0 (20040413)</SPAN></ADDRESS></BODY></HTML>
