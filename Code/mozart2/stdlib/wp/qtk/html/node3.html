<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>3 Tutorial example: a notepad application</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node2.html#chapter.prototyper">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node4.html#chapter.basics">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.example"><H1><A name="chapter.example">3 Tutorial example: a notepad application</A></H1><P>This chapter describes by an example how a GUI (graphical user interface) is built using the QTk module. The creation of widgets, their geometry inside the window and their interaction with Mozart are described. </P><DIV id="figure.picture3"><HR><P><A name="figure.picture3"></A></P><DIV align="center"><IMG alt="" src="picture3.gif"></DIV><P class="caption"><STRONG>Figure&nbsp;3.1:</STRONG> Notepad application</P><HR></DIV><P></P><H2><A name="label2">3.1 Geometry management</A></H2><P>The example application consists of a window composed by </P><UL><LI><P>A toolbar with the following buttons: Save, Load and Quit.</P></LI><LI><P>A main area where the user can type the text.</P></LI></UL><P> The construction of the window is completely described by a record. This record defines the widgets that compose the window, how these widgets must be placed and what is their behavior upon window resizing. The label of the record defines the widget type while the features define its parameters. Some widgets act as containers for other widgets. The two main containers are: </P><UL><LI><P><CODE>td</CODE>: all widgets contained in this one are placed top to down</P></LI><LI><P><CODE>lr</CODE>: all widgets contained in this one are placed left to right</P></LI></UL><P> In this application, the toolbar is composed of <CODE>button</CODE> widgets. The <CODE>text</CODE> parameter defines the text inside the button. </P><DIV id="figure.picture1"><HR><P><A name="figure.picture1"></A></P><DIV align="center"><IMG alt="" src="picture1.gif"></DIV><P class="caption"><STRONG>Figure&nbsp;3.2.</STRONG></P><HR></DIV><P>The toolbar is described by: </P><BLOCKQUOTE class="code"><CODE>Toolbar=lr(button(text:<SPAN class="string">&quot;Save&quot;</SPAN>)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Load&quot;</SPAN>)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Quit&quot;</SPAN>))</CODE></BLOCKQUOTE><P> which means: place these three buttons respectively from left to right, each button taking the size it needs to display itself. Combining with the text widget, we obtain: </P><BLOCKQUOTE class="code"><CODE>Description=td(Toolbar<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text)</CODE></BLOCKQUOTE><P> which means: place the toolbar and the text respectively from top to bottom, each widget taking the size it needs to display itself.</P><P>Now we can build a window from this description by the command: </P><BLOCKQUOTE class="code"><CODE>Window={QTk<SPAN class="keyword">.</SPAN>build&nbsp;Description}</CODE></BLOCKQUOTE><P> This window is hidden by default and must be explicitly shown: </P><BLOCKQUOTE class="code"><CODE>{Window&nbsp;show}</CODE></BLOCKQUOTE><P> This is already a first version of the application UI, but it still requires more work. Something that is easily noticeable by resizing the window, is that the widgets don't resize in a very clever way inside the window. </P><DIV id="figure.picture2"><HR><P><A name="figure.picture2"></A></P><DIV align="center"><IMG alt="" src="picture2.gif"></DIV><P class="caption"><STRONG>Figure&nbsp;3.3.</STRONG></P><HR></DIV><P>One expects the toolbar to stick itself to the top left of the window, and the text widget to take all remaining available size below. All widgets have a glue parameter that specifies constraints to their geometry management. Valid values for the glue parameters are atoms that are combinations of <CODE>n</CODE>, <CODE>s</CODE>, <CODE>w</CODE> and <CODE>e</CODE>. By default a widget takes as much place as it needs to draw itself, and if it receives more space than needed, the widget is centered inside that space. By specifying <CODE>n</CODE> (resp. <CODE>s</CODE>, <CODE>w</CODE>, <CODE>e</CODE>) you enforce the north (resp. south, west and east) border of the widget to glue to its top (resp. down, left, right) neighbor. If you specify both <CODE>ns</CODE> (resp. <CODE>we</CODE>) you enforce both opposite border to stick to their respective neighbors, resulting in the widget taking all the vertical (resp. horizontal) space available.</P><P>Using the glue parameter we define: </P><BLOCKQUOTE class="code"><CODE>Toolbar=lr(glue:nw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="comment">%&nbsp;the&nbsp;toolbar&nbsp;glues&nbsp;itself&nbsp;to&nbsp;the&nbsp;top&nbsp;left&nbsp;of&nbsp;the&nbsp;window<BR></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Save&quot;</SPAN>&nbsp;glue:w)&nbsp;&nbsp;<SPAN class="comment">%&nbsp;the&nbsp;button&nbsp;glues&nbsp;itself&nbsp;to&nbsp;the&nbsp;left&nbsp;of&nbsp;the&nbsp;lr&nbsp;widget<BR></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Load&quot;</SPAN>&nbsp;glue:w)&nbsp;&nbsp;<SPAN class="comment">%&nbsp;idem<BR></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Quit&quot;</SPAN>&nbsp;glue:w))&nbsp;<SPAN class="comment">%&nbsp;idem<BR></SPAN>&nbsp;<BR>Description=td(Toolbar<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text(glue:nswe))</CODE></BLOCKQUOTE><P> Note that the very first <CODE>td</CODE> or <CODE>lr</CODE> widget is always implicitly <CODE>glue:nswe</CODE>. Building and showing the window again, we obtain an application that has a complete graphical user interface, except that it is an empty shell: there is no interaction defined between the application and the user.</P><H2><A name="label3">3.2 Interaction with the user</A></H2><P>An action can be associated to buttons. It is executed when the user clicks the button: </P><BLOCKQUOTE class="code"><CODE>button(text:<SPAN class="string">&quot;Quit&quot;</SPAN>&nbsp;glue:w&nbsp;action:<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>}&nbsp;{Application<SPAN class="keyword">.</SPAN>exit&nbsp;0}&nbsp;<SPAN class="keyword">end</SPAN>)}</CODE></BLOCKQUOTE><P> This definition makes the oz application terminate when the user clicks the Quit button. Another possibility is to just close the window using this particular parameter: </P><BLOCKQUOTE class="code"><CODE>button(text:<SPAN class="string">&quot;Quit&quot;</SPAN>&nbsp;glue:w&nbsp;action:toplevel<SPAN class="keyword">#</SPAN>close)</CODE></BLOCKQUOTE><P> Let's make procedures for the Save and Load buttons. The new definitions for these buttons are: </P><BLOCKQUOTE class="code"><CODE>button(text:<SPAN class="string">&quot;Save&quot;</SPAN>&nbsp;glue:w&nbsp;action:SaveText)<BR>button(text:<SPAN class="string">&quot;Load&quot;</SPAN>&nbsp;glue:w&nbsp;action:LoadText)</CODE></BLOCKQUOTE><P> Where <CODE>LoadText</CODE> and <CODE>SaveText</CODE> do these: </P><UL><LI><P>Ask a filename. Standard dialog boxes are provided in QTk: <CODE>{QTk<SPAN class="keyword">.</SPAN>dialogbox&nbsp;load(<SPAN class="keyword">...</SPAN>)}</CODE> and <CODE>{QTk<SPAN class="keyword">.</SPAN>dialogbox&nbsp;save(<SPAN class="keyword">...</SPAN>)}</CODE></P></LI><LI><P>Get the contents of the text widget and save it to the file or get the contents of the file and change the contents of the text widget accordingly.</P></LI></UL><P> We need a way to dynamically change or get the state of the text widget, i.e. interact with it. This is what handles are used for: </P><BLOCKQUOTE class="code"><CODE>TextHandle<BR>Description=td(Toolbar<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text(glue:nswe&nbsp;handle:TextHandle))</CODE></BLOCKQUOTE><P> After the window is built, the (unbound) variable TextHandle is bound to an object that controls the text widget. The current text can be obtained by: </P><BLOCKQUOTE class="code"><CODE>{TextHandle&nbsp;get($)}</CODE></BLOCKQUOTE><P> and set by: </P><BLOCKQUOTE class="code"><CODE>{TextHandle&nbsp;set(SomeValue)}</CODE></BLOCKQUOTE><P> We can now write the <CODE>SaveText</CODE> and <CODE>LoadText</CODE> procedures: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">SaveText</SPAN>}<BR>&nbsp;&nbsp;Name={QTk<SPAN class="keyword">.</SPAN>dialogbox&nbsp;save($)}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">try</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;File={New&nbsp;Open<SPAN class="keyword">.</SPAN>file&nbsp;init(name:Name&nbsp;flags:[write&nbsp;create&nbsp;truncate])}<BR>&nbsp;&nbsp;&nbsp;&nbsp;Contents={TextHandle&nbsp;get($)}<BR>&nbsp;&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;{File&nbsp;write(vs:Contents)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;{File&nbsp;close}<BR>&nbsp;&nbsp;<SPAN class="keyword">catch</SPAN>&nbsp;_&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;<BR><SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">LoadText</SPAN>}<BR>&nbsp;&nbsp;Name={QTk<SPAN class="keyword">.</SPAN>dialogbox&nbsp;load($)}<BR>&nbsp;&nbsp;Contents={TextHandle&nbsp;get($)}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">try</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;File={New&nbsp;Open<SPAN class="keyword">.</SPAN>file&nbsp;init(name:Name)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;Contents={File&nbsp;read(list:$&nbsp;size:all)}<BR>&nbsp;&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;{TextHandle&nbsp;set(Contents)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;{File&nbsp;close}<BR>&nbsp;&nbsp;<SPAN class="keyword">catch</SPAN>&nbsp;_&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> And the application is now complete.</P><H2><A name="label4">3.3 Enhancements</A></H2><P>Instead of using standard buttons, we might want to use a toolbar look and feel. A QTk widget exists for that purpose: <CODE>tbbutton</CODE>. As its interface is the same as standard buttons, we just have to change the label of this record: </P><BLOCKQUOTE class="code"><CODE>Toolbar=lr(glue:we<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tbbutton(text:<SPAN class="string">&quot;Save&quot;</SPAN>&nbsp;glue:w)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tbbutton(text:<SPAN class="string">&quot;Load&quot;</SPAN>&nbsp;glue:w)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tbbutton(text:<SPAN class="string">&quot;Quit&quot;</SPAN>&nbsp;glue:w))</CODE></BLOCKQUOTE><P> If there is a lot of text, scrollbars are required for easy mouse navigation. A vertical scrollbar can be added with this parameter: </P><BLOCKQUOTE class="code"><CODE>text(glue:nswe&nbsp;handle:TextHandle&nbsp;tdscrollbar:<SPAN class="keyword">true</SPAN>)</CODE></BLOCKQUOTE><P> Also one may prefer the white color as background color for the text: </P><BLOCKQUOTE class="code"><CODE>text(glue:nswe&nbsp;handle:TextHandle&nbsp;tdscrollbar:<SPAN class="keyword">true</SPAN>&nbsp;bg:white)</CODE></BLOCKQUOTE><P> As you can see, widgets are highly configurable by parameters. Most of these parameters can be dynamically changed: </P><BLOCKQUOTE class="code"><CODE>{TextHandle&nbsp;set(bg:white)}</CODE></BLOCKQUOTE><P> Sets the background to <CODE>white</CODE>, at any time as long as the window containing that particular widget exists (ie is created and not yet closed). Interfaces to widgets were made as uniform as possible and similar widgets have similar parameters name and use. </P><H2><A name="label5">3.4 The complete code</A></H2><P class="margin"><A href="notepad.oz">Source File</A></P><P> </P><BLOCKQUOTE><PRE><SPAN class="keyword">declare</SPAN>&nbsp;<BR>[QTk]={Module<SPAN class="keyword">.</SPAN>link&nbsp;[<SPAN class="string">&quot;http://www.info.ucl.ac.be/people/ned/qtk/QTk.ozf&quot;</SPAN>]}<BR>&nbsp;<BR><SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">SaveText</SPAN>}<BR>&nbsp;&nbsp;&nbsp;Name={QTk<SPAN class="keyword">.</SPAN>dialogbox&nbsp;save($)}<BR><SPAN class="keyword">in</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">try</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;File={New&nbsp;Open<SPAN class="keyword">.</SPAN>file&nbsp;init(name:Name&nbsp;flags:[write&nbsp;create&nbsp;truncate])}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Contents={TextHandle&nbsp;get($)}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{File&nbsp;write(vs:Contents)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{File&nbsp;close}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">catch</SPAN>&nbsp;_&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR>&nbsp;<BR><SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">LoadText</SPAN>}<BR>&nbsp;&nbsp;&nbsp;Name={QTk<SPAN class="keyword">.</SPAN>dialogbox&nbsp;load($)}<BR><SPAN class="keyword">in</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">try</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;File={New&nbsp;Open<SPAN class="keyword">.</SPAN>file&nbsp;init(name:Name)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Contents={File&nbsp;read(list:$&nbsp;size:all)}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{TextHandle&nbsp;set(Contents)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{File&nbsp;close}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">catch</SPAN>&nbsp;_&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;<BR>Toolbar=lr(glue:we<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tbbutton(text:<SPAN class="string">&quot;Save&quot;</SPAN>&nbsp;glue:w&nbsp;action:SaveText)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tbbutton(text:<SPAN class="string">&quot;Load&quot;</SPAN>&nbsp;glue:w&nbsp;action:LoadText)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tbbutton(text:<SPAN class="string">&quot;Quit&quot;</SPAN>&nbsp;glue:w&nbsp;action:toplevel<SPAN class="keyword">#</SPAN>close))<BR>&nbsp;<BR>TextHandle<BR>&nbsp;<BR>Window={QTk<SPAN class="keyword">.</SPAN>build&nbsp;td(Toolbar<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text(glue:nswe&nbsp;handle:TextHandle&nbsp;bg:white&nbsp;tdscrollbar:<SPAN class="keyword">true</SPAN>))}<BR>&nbsp;<BR>{Window&nbsp;show}<BR>&nbsp;<BR></PRE></BLOCKQUOTE><P></P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node2.html#chapter.prototyper">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node4.html#chapter.basics">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS>Donatien Grolaux<BR><SPAN class="version">Version 1.3.0 (20040413)</SPAN></ADDRESS></BODY></HTML>
