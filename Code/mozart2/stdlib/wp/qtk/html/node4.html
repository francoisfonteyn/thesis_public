<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>4 Basics</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node3.html#chapter.example">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node5.html#chapter.advanced">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.basics"><H1><A name="chapter.basics">4 Basics</A></H1><P>The tutorial example shows the building of a simple application and how its GUI is expressed in QTk. This chapter details all the information needed to start working with QTk. The geometry management and the different principles of QTk are described. </P><DIV id="basics.geometry"><H2><A name="basics.geometry">4.1 Geometry management</A></H2><P>The geometry management is done by means of dedicated container widgets: </P><UL><LI><P><CODE>td</CODE> which organizes widgets top down.</P></LI><LI><P><CODE>lr</CODE> which organizes widgets from left to right.</P></LI></UL><P> By default all widgets take exactly the size they need to draw themselves. If there is more space available, widgets are centered by default inside that space. That behavior can be changed by the <CODE>glue</CODE> parameter. Valid values for this parameter are atoms that are a combination of the letters <CODE>n</CODE>, <CODE>s</CODE>, <CODE>w</CODE> and <CODE>e</CODE> that correspond respectively to the top, bottom, left and right side of the widget. Gluing a side consist of placing a constraint on that side with its corresponding neighbor. Gluing two opposite sides results in the widget taking all the space available in the direction of these sides.</P><P>Let's consider:</P><P><CODE>lr(glue:nswe<BR>&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Left&quot;</SPAN>)<BR>&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Right&quot;</SPAN>))</CODE> </P><DIV id="figure.picture4"><HR><P><A name="figure.picture4"></A></P><DIV align="center"><IMG alt="" src="picture4.gif"></DIV><P class="caption"><STRONG>Figure&nbsp;4.1.</STRONG></P><HR></DIV><P>This describes a frame with two buttons placed side by side horizontally. If the user resizes the window, the frame is split in equal space and each button is centered within its own space. </P><DIV id="figure.picture5"><HR><P><A name="figure.picture5"></A></P><DIV align="center"><IMG alt="" src="picture5.gif"></DIV><P class="caption"><STRONG>Figure&nbsp;4.2.</STRONG></P><HR></DIV><P>We can add constraints to control the geometry of the widgets by using the <CODE>glue</CODE> parameter:</P><P> <CODE>lr(glue:nswe<BR>&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Left&quot;</SPAN>&nbsp;glue:e)<BR>&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Right&quot;</SPAN>)</CODE> </P><DIV id="figure.picture6"><HR><P><A name="figure.picture6"></A></P><DIV align="center"><IMG alt="" src="picture6.gif"></DIV><P class="caption"><STRONG>Figure&nbsp;4.3.</STRONG></P><HR></DIV><P>Now the east border of the left button is constrained with its right neighbor. When the window is resized, the two buttons stick themselves together, centering themselves in all the available space.</P><P><CODE>lr(glue:nswe<BR>&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Left&quot;</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Right&quot;</SPAN>&nbsp;glue:w))</CODE> </P><DIV id="figure.picture7"><HR><P><A name="figure.picture7"></A></P><DIV align="center"><IMG alt="" src="picture6.gif"></DIV><P class="caption"><STRONG>Figure&nbsp;4.4.</STRONG></P><HR></DIV><P>This is the same as the previous example as the west border of right button is constrained with its left neighbor. </P><P> It is also possible to ask widgets to take as much space as available:</P><P><CODE>lr(glue:nswe<BR>&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Left&quot;</SPAN>&nbsp;glue:we)<BR>&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Right&quot;</SPAN>))</CODE> </P><DIV id="figure.picture8"><HR><P><A name="figure.picture8"></A></P><DIV align="center"><IMG alt="" src="picture8.gif"></DIV><P class="caption"><STRONG>Figure&nbsp;4.5.</STRONG></P><HR></DIV><P>The first button is glued to both horizontal sides. The second button takes just the necessary size to draw itself (default behavior). As a result, the second button is stuck to the right while the first button takes all the remaining available horizontal space.</P><P> <CODE>td</CODE> widgets can be placed inside <CODE>lr</CODE> widgets and vice versa. By combining these widgets and the <CODE>glue</CODE> parameter, complex windows can be built. However it is hard to obtain windows that need a grid structure like a calculator: </P><P><CODE>td(lr(button(text:<SPAN class="string">&quot;One&quot;</SPAN>)&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Two&quot;</SPAN>)&nbsp;&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Three&quot;</SPAN>))<BR>&nbsp;&nbsp;&nbsp;lr(button(text:<SPAN class="string">&quot;Four&quot;</SPAN>)&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Five&quot;</SPAN>)&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Six&quot;</SPAN>))<BR>&nbsp;&nbsp;&nbsp;lr(button(text:<SPAN class="string">&quot;Seven&quot;</SPAN>)&nbsp;button(text:<SPAN class="string">&quot;Height&quot;</SPAN>)&nbsp;button(text:<SPAN class="string">&quot;Nine&quot;</SPAN>))<BR>&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Zero&quot;</SPAN>))</CODE> </P><DIV id="figure.picture9"><HR><P><A name="figure.picture9"></A></P><DIV align="center"><IMG alt="" src="picture9.gif"></DIV><P class="caption"><STRONG>Figure&nbsp;4.6.</STRONG></P><HR></DIV><P>As the text labels aren't the same width, the buttons are not vertically centered. There is a way to achieve this: <CODE>newline</CODE>. </P><P><CODE>lr(button(text:<SPAN class="string">&quot;One&quot;</SPAN>)&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Two&quot;</SPAN>)&nbsp;&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Three&quot;</SPAN>)&nbsp;newline<BR>&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Four&quot;</SPAN>)&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Five&quot;</SPAN>)&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Six&quot;</SPAN>)&nbsp;&nbsp;&nbsp;newline<BR>&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Seven&quot;</SPAN>)&nbsp;button(text:<SPAN class="string">&quot;Height&quot;</SPAN>)&nbsp;button(text:<SPAN class="string">&quot;Nine&quot;</SPAN>)&nbsp;&nbsp;newline<BR>&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Zero&quot;</SPAN>))</CODE> </P><DIV id="figure.picture10"><HR><P><A name="figure.picture10"></A></P><DIV align="center"><IMG alt="" src="picture10.gif"></DIV><P class="caption"><STRONG>Figure&nbsp;4.7.</STRONG></P><HR></DIV><P><CODE>newline</CODE> introduces a new line (or column for the <CODE>td</CODE> widget) using a grid structure, such that widgets are aligned on several lines.</P><P>Another uselful command is <CODE>empty</CODE> which leaves an empty space: </P><P><CODE>lr(button(text:<SPAN class="string">&quot;One&quot;</SPAN>)&nbsp;button(text:<SPAN class="string">&quot;Two&quot;</SPAN>)&nbsp;button(text:<SPAN class="string">&quot;Three&quot;</SPAN>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newline<BR>&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Four&quot;</SPAN>)&nbsp;button(text:<SPAN class="string">&quot;Five&quot;</SPAN>)&nbsp;button(text:<SPAN class="string">&quot;Six&quot;</SPAN>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newline<BR>&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Seven&quot;</SPAN>)&nbsp;button(text:<SPAN class="string">&quot;Height&quot;</SPAN>)&nbsp;button(text:<SPAN class="string">&quot;Nine&quot;</SPAN>)&nbsp;newline<BR>&nbsp;&nbsp;&nbsp;empty&nbsp;button(text:<SPAN class="string">&quot;Zero&quot;</SPAN>)&nbsp;empty)</CODE> </P><DIV id="figure.picture11"><HR><P><A name="figure.picture11"></A></P><DIV align="center"><IMG alt="" src="picture11.gif"></DIV><P class="caption"><STRONG>Figure&nbsp;4.8.</STRONG></P><HR></DIV><P></P><P> Note that <CODE>newline</CODE> and <CODE>empty</CODE> are <EM>not</EM> widgets and that they don't support parameters (they don't have a <CODE>glue</CODE> or a <CODE>handle</CODE> parameter for instance). </P></DIV><DIV id="basics.interaction"><H2><A name="basics.interaction">4.2 Interacting with widgets</A></H2><P> The description record of the window defines: </P><UL><LI><P>The geometry parameters of the window</P></LI><LI><P>The initial state of the widgets</P></LI></UL><P> This section describes how the inner state of the widgets can be dynamically changed. Changing the geometry of the window is possible using the <CODE>placeholder</CODE> or the <CODE>grid</CODE> widgets. This will not be detailed here (see <A href="node20.html#chapter.widgets.placeholder">Section&nbsp;7.13</A>).</P><P> To modify the state of a widget, we need a way to reference this widget: the <CODE>handle</CODE> parameter. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;B<BR>&nbsp;&nbsp;Desc=td(button(text:<SPAN class="string">&quot;One&quot;</SPAN>&nbsp;handle:B))<BR>&nbsp;&nbsp;Window={QTk<SPAN class="keyword">.</SPAN>build&nbsp;Desc}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;{Window&nbsp;show}<BR>&nbsp;&nbsp;{B&nbsp;set(text:<SPAN class="string">&quot;Two&quot;</SPAN>)}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> While building the window, all <CODE>handle</CODE> variables are bound to objects that grant control over the corresponding widgets. These objects have interfaces depending on the nature of the widget they are controlling. However these interfaces were made as uniform as possible and contain at least the following methods: </P><UL><LI><P><CODE>set(parameter:value)</CODE>: changes the value of the parameter of the widget.</P></LI><LI><P><CODE>get(parameter:free_variable)</CODE>: binds the variable to the contents of the parameter of the widget.</P></LI></UL><P> Several parameters can be set or get in a single command: </P><BLOCKQUOTE class="code"><CODE>{B&nbsp;set(text:<SPAN class="string">&quot;Three&quot;</SPAN>&nbsp;bg:red)}</CODE></BLOCKQUOTE><P> See the specific widget documentation for specific parameters.</P><P> Another way of getting a handle is to use the feature parameter: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;Desc=td(button(text:<SPAN class="string">&quot;One&quot;</SPAN>&nbsp;feature:button))<BR>&nbsp;&nbsp;Window={QTk<SPAN class="keyword">.</SPAN>build&nbsp;Desc}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;{Window&nbsp;show}<BR>&nbsp;&nbsp;{Window<SPAN class="keyword">.</SPAN>button&nbsp;set(text:<SPAN class="string">&quot;Two&quot;</SPAN>)}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> This is strictly equivalent to the previous example. Instead of using a variable, this method uses a feature of the parent object. Using handles or features is just a matter of taste as both methods are equivalent.</P><P> Most widgets have an <CODE>init</CODE> parameter that sets the initial state of the widget (depending on the nature of the widget): </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;Window={QTk<SPAN class="keyword">.</SPAN>build&nbsp;td(checkbutton(init:<SPAN class="keyword">true</SPAN>&nbsp;&nbsp;text:<SPAN class="string">&quot;Initial&nbsp;state&nbsp;is&nbsp;on&quot;</SPAN>)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;checkbutton(init:<SPAN class="keyword">false</SPAN>&nbsp;text:<SPAN class="string">&quot;Initial&nbsp;state&nbsp;is&nbsp;off&quot;</SPAN>))}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;{Window<SPAN class="keyword">.</SPAN>show}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> Many widgets have also a <CODE>return</CODE> parameter to help building dialog box windows. <CODE>return</CODE> parameters are bound to the main (widget specific) value of their widgets WHEN the window is closed. For example a dialog box that asks for the name of the user can be written as: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;E<BR>&nbsp;&nbsp;Window={QTk<SPAN class="keyword">.</SPAN>build&nbsp;lr(label(text:<SPAN class="string">&quot;Enter&nbsp;your&nbsp;name&nbsp;then&nbsp;close&nbsp;the&nbsp;window:&quot;</SPAN>)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry(return:E))}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;{Window&nbsp;show}<BR>&nbsp;&nbsp;{Wait&nbsp;E}&nbsp;&nbsp;&nbsp;<SPAN class="comment">%&nbsp;E&nbsp;is&nbsp;bound&nbsp;when&nbsp;the&nbsp;window&nbsp;is&nbsp;closed<BR></SPAN>&nbsp;&nbsp;{Browse&nbsp;E}&nbsp;<SPAN class="comment">%&nbsp;Displays&nbsp;E<BR></SPAN><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> See the widget reference documentation for specific widget support of the <CODE>return</CODE> parameter.</P><P></P></DIV><H2><A name="label6">4.3  Events and actions </A></H2><P>So far we are still unable to dynamically interact with the user, as we don't know what he is doing. Actions can be associated to user events. Many widgets have a main event corresponding to the most obvious use of the widget. All other events can be finely defined using the <CODE>bind</CODE> method. </P><DIV id="basics.events"><H3><A name="basics.events">4.3.1 Main events</A></H3><P>Most widgets raise an event just after the user has interacted with them: </P><UL><LI><P>After the user clicks on a button.</P></LI><LI><P>After the user selects an item in a list.</P></LI><LI><P>After the user types a letter in an entry.</P></LI><LI><P>After the user checks or unchecks a checkbutton.</P></LI><LI><P>And so on depending on the widget type.</P></LI></UL><P> These are called main events. Most simple uses are covered by these events. These events are defined by the <CODE>action</CODE> parameter of the object. An action can have one of these forms: </P><UL><LI><P>A zero parameter procedure.</P></LI><LI><P>A pair object_variable#method.</P></LI><LI><P>A pair port_variable#message.</P></LI><LI><P>A pair <CODE>toplevel</CODE>#method.</P></LI><LI><P>A pair <CODE>widget</CODE>#method.</P></LI></UL><P> Where the last two are just shortcuts to object_variable#method with object_variable being a reference respectively to the window or the widget itself. A frequent use is <CODE>button(text:<SPAN class="string">&quot;Close&quot;</SPAN>&nbsp;action:toplevel<SPAN class="keyword">#</SPAN>close)</CODE>. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">C</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">show</SPAN>(Msg)&nbsp;{Show&nbsp;Msg}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;O={New&nbsp;C&nbsp;init}<BR>&nbsp;<BR>&nbsp;&nbsp;R<BR>&nbsp;&nbsp;P={NewPort&nbsp;R}<BR>&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;{ForAll&nbsp;R&nbsp;<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;Msg}&nbsp;{Show&nbsp;Msg}&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;<BR>&nbsp;&nbsp;Window={QTk<SPAN class="keyword">.</SPAN>build&nbsp;td(button(text:<SPAN class="string">&quot;Procedure&quot;</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action:<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>}&nbsp;{Show&nbsp;<SPAN class="string">'Procedure'</SPAN>}&nbsp;<SPAN class="keyword">end</SPAN>)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Object&quot;</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action:O<SPAN class="keyword">#</SPAN>show(<SPAN class="string">'Object'</SPAN>))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Port&quot;</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action:P<SPAN class="keyword">#</SPAN><SPAN class="string">'Port'</SPAN>)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;toplevel&quot;</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action:toplevel<SPAN class="keyword">#</SPAN>set(title:<SPAN class="string">&quot;Toplevel&quot;</SPAN>))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;widget&quot;</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action:widget<SPAN class="keyword">#</SPAN>set(text:<SPAN class="string">&quot;widget&nbsp;clicked&quot;</SPAN>)))}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;{Window&nbsp;show}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P></P></DIV><H3><A name="label7">4.3.2 Concurrency between actions</A></H3><P>A unique thread is associated to each QTk window. All actions are serialized and executed in the first in first out order. If the window is closed, pending actions are ignored. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;Window={QTk<SPAN class="keyword">.</SPAN>build&nbsp;td(button(text:<SPAN class="string">&quot;1&quot;</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action:<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>}&nbsp;{Delay&nbsp;2000}&nbsp;{Show&nbsp;1}&nbsp;<SPAN class="keyword">end</SPAN>)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;2&quot;</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action:<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>}&nbsp;{Delay&nbsp;2000}&nbsp;{Show&nbsp;2}&nbsp;<SPAN class="keyword">end</SPAN>)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;close&quot;</SPAN>&nbsp;action:toplevel<SPAN class="keyword">#</SPAN>close))}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;{Window&nbsp;show}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> See specific widget documentations for further details.</P><P> </P><DIV id="basics.otherevents"><H3><A name="basics.otherevents">4.3.3 Other events</A></H3><P>There are many other events that you might want to observe. Widgets have the <CODE>bind</CODE> method to add actions to all these events.</P><P> <CODE><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;Window={QTk<SPAN class="keyword">.</SPAN>build&nbsp;td(canvas(glue:nswe&nbsp;handle:C))}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;{Window&nbsp;show}<BR>&nbsp;&nbsp;{C&nbsp;bind(event:<SPAN class="string">&quot;&lt;1&gt;&quot;</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args:[int(x)&nbsp;int(y)]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action:<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X&nbsp;Y}&nbsp;{C&nbsp;create(circle&nbsp;X<SPAN class="keyword">-</SPAN>5&nbsp;Y<SPAN class="keyword">-</SPAN>5&nbsp;X<SPAN class="keyword">+</SPAN>5&nbsp;Y<SPAN class="keyword">+</SPAN>5)}&nbsp;<SPAN class="keyword">end</SPAN>)}<BR><SPAN class="keyword">end</SPAN></CODE> </P><P>The <CODE>event</CODE> parameter is a string describing the event to listen. Here <CODE><SPAN class="string">&quot;&lt;1&gt;&quot;</SPAN></CODE> is the left mouse button being pushed down. The <CODE>action</CODE> parameter can only take the procedure, method or port message forms. See <A href="node45.html#misc.events.names">Section&nbsp;8.11.1</A> for valid <CODE>event</CODE> parameter forms.</P><P>Events can also receive parameters. The example above shows how the coordinates of the mouse are obtained. The parameters to receive are specified by the <CODE>args</CODE> parameter (see <A href="node45.html#misc.events.args">Section&nbsp;8.11.2</A>). The action is called with as much parameters as specified with <CODE>args</CODE>. </P></DIV></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node3.html#chapter.example">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node5.html#chapter.advanced">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS>Donatien Grolaux<BR><SPAN class="version">Version 1.3.0 (20040413)</SPAN></ADDRESS></BODY></HTML>
